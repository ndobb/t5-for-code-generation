[
  {
    "intent": "Join in a string with a space between the words, all the values with key \"word\" you find, for every value within \"annotated_sent0['tokens']\" ",
    "snippet": " \".join(token['word'] for token in annotated_sent0['tokens'])\""
  },
  {
    "intent": "Set the proxy to 'http://proxy.example.com:3128'. The username of the proxy is \"anithas\" and the password of the proxy is \"asfaleia\"",
    "snippet": " \"nltk.set_proxy('http://proxy.example.com:3128',('anithas', 'asfaleia'))\""
  },
  {
    "intent": "Check if the word \"word\" occur in the brown corpus category news",
    "snippet": "'word' in brown.words(categories='news')"
  },
  {
    "intent": "define LF_action_help with argument text that returns TRUTH if LF_action_help is in ACTIONS otherwise return FAKE",
    "snippet": "@labeling_function()\ndef LF_action_help(text):\n    return TRUTH if 'LF_action_help' in ACTIONS else FAKE"
  },
  {
    "intent": "Write a function disaster_location with input text that returns TRUTH if 'LF_disaster_location' is in LOCATIONS, otherwise FAKE",
    "snippet": "@labeling_function()\ndef LF_disaster_location(text):\n    return TRUTH if 'LF_disaster_location' in LOCATIONS else FAKE"
  },
  {
    "intent": "define a function that accepts x as input and returns BASEBALL if the word bat is in the lowercased x string, otherwise SKIP",
    "snippet": "@labeling_function()\ndef bat(x):\n  return BASEBALL if 'bat' in x.lower() else SKIP"
  },
  {
    "intent": "If 'bat' is is in lowercased x, return BASEBALL, otherwise return SKIP",
    "snippet": "@labeling_function()\ndef bat(x):\n  return BASEBALL if 'bat' in x.lower() else SKIP"
  },
  {
    "intent": "I need a function that takes as input a text variable x and it checks if 'bat' is in x. If it is, it returns BASEBALL, otherwise it returns SKIP.",
    "snippet": "@labeling_function()\ndef bat(x):\n  return BASEBALL if 'bat' in x.lower() else SKIP"
  },
  {
    "intent": "write me a function that takes an argument x and if the word 'bat' is in lowercased x it returns the label BASEBALL. Otherwise it should return the label SKIP",
    "snippet": "@labeling_function()\ndef bat(x):\n  return BASEBALL if 'bat' in x.lower() else SKIP"
  },
  {
    "intent": "write me a function  called bat that takes an input x and returns BASEBALL if the word 'bat' is in lowercased x else SKIP",
    "snippet": "@labeling_function()\ndef bat(x):\n  return BASEBALL if 'bat' in x.text.lower() else SKIP"
  },
  {
    "intent": "Write a function that shall return SPAM if 'check' is in the lowercased field named text of input variable x, otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef check(x):\n    return SPAM if 'check' in x.text.lower() else ABSTAIN"
  },
  {
    "intent": "Return a label of SPAM if 'check' in the lowercased text, otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef check(x):\n    return SPAM if 'check' in x.text.lower() else ABSTAIN"
  },
  {
    "intent": "I want a function 'coral reef' that takes an input x and returns SEA-RELATED if coral reef is in the lowercased field text of x, otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef check_out(x):\n    return SEA-RELATED if 'coral reef' in x.text.lower() else ABSTAIN"
  },
  {
    "intent": "Return a label of SEA-RELATED if 'coral reef' in the lowercased field named text of input variable x, otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef check_out(x):\n    return SEA-RELATED if 'coral reef' in x.text.lower() else ABSTAIN"
  },
  {
    "intent": "Give me function whose name is coral reef and sees if the lowercased text field of the input variable x contains the word 'coral reef' in it. If yes, then it should return SEA-RELATED, outherwise it should return ABSTAIN",
    "snippet": "@labeling_function()\ndef check_out(x):\n    return SEA-RELATED if 'coral reef' in x.text.lower() else ABSTAIN"
  },
  {
    "intent": "I want a function 'check out' that takes an input x and returns SPAM if check out is in the lowercased field text of x, otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef check_out(x):\n    return SPAM if 'check out' in x.text.lower() else ABSTAIN"
  },
  {
    "intent": "Return a label of SPAM if 'check out' in the lowercased field named text of input variable x, otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef check_out(x):\n    return SPAM if 'check out' in x.text.lower() else ABSTAIN"
  },
  {
    "intent": "Give me function whose name is check out and sees if the lowercased text field of the input variable x contains the word 'check out' in it. If yes, then it should return SPAM, outherwise it should return ABSTAIN",
    "snippet": "@labeling_function()\ndef check_out(x):\n    return SPAM if 'check out' in x.text.lower() else ABSTAIN"
  },
  {
    "intent": "I'd like you to define a function that takes an input x and if x's field country code is 'BE'. then it will return BE, if it's NL it 'll return NL, otherwise it returns ABSTAIN.",
    "snippet": "@labeling_function()\ndef country_code(x):\n    if x.country_code == 'BE':\n        return BE\n    elif x.country_code == 'NL':\n        return NL\n    else:\n        return ABSTAIN"
  },
  {
    "intent": "Write me a function called country_code that takes a variable x and if x's country code is equal to 'BE'. then return BE, if it's equal to NL return NL, otherwise return ABSTAIN.",
    "snippet": "@labeling_function()\ndef country_code(x):\n    if x.country_code == 'BE':\n        return BE\n    elif x.country_code == 'NL':\n        return NL\n    else:\n        return ABSTAIN"
  },
  {
    "intent": "If x's country code is equal to 'BE'. then return BE, if it's equal to NL return NL, otherwise return ABSTAIN.",
    "snippet": "@labeling_function()\ndef country_code(x):\n    if x.country_code == 'BE':\n        return BE\n    elif x.country_code == 'NL':\n        return NL\n    else:\n        return ABSTAIN"
  },
  {
    "intent": "I need a function that takes an input x and if x.country code is equal to 'BE'. then it will return BE, if it's equal to NL it 'll return NL, otherwise it should return ABSTAIN.",
    "snippet": "@labeling_function()\ndef country_code(x):\n    if x.country_code == 'BE':\n        return BE\n    elif x.country_code == 'NL':\n     return NL\n    else:\n        return ABSTAIN"
  },
  {
    "intent": "I want a function that will take as input a variable x and if x's field country code is equal to 'BE'. then it will return BE, if it's equal to NL it 'll return NL, otherwise it should return ABSTAIN.",
    "snippet": "@labeling_function()\ndef country_code(x):\n    if x.country_code == 'BE':\n        return BE\n    elif x.country_code == 'NL':\n     return NL\n    else:\n        return ABSTAIN"
  },
  {
    "intent": "I'd like you to define a function that takes an input x and if x's field country code is 'DE'. then it will return DE, if it's GR it 'll return GR, otherwise it returns ABSTAIN.",
    "snippet": "@labeling_function()\ndef country_code(x):\n    if x.country_code == 'DE':\n        return DE\n    elif x.country_code == 'GR':\n        return GR\n    else:\n        return ABSTAIN"
  },
  {
    "intent": "I want a function that will take as input a variable x and if x's field country code is equal to 'ES'. then it will return ES, if it's equal to RUS it 'll return RUS, otherwise it should return ABSTAIN.",
    "snippet": "@labeling_function()\ndef country_code(x):\n    if x.country_code == 'ES':\n        return ES\n    elif x.country_code == 'RUS':\n     return RUS\n    else:\n        return ABSTAIN"
  },
  {
    "intent": "If x's country code is equal to 'FR'. then return FR, if it's equal to AU return AU, otherwise return ABSTAIN.",
    "snippet": "@labeling_function()\ndef country_code(x):\n    if x.country_code == 'FR':\n        return FR\n    elif x.country_code == 'AU':\n        return AU\n    else:\n        return ABSTAIN"
  },
  {
    "intent": "I need a function that takes an input x and if x.country code is equal to 'NO'. then it will return NO, if it's equal to SLO it 'll return SLO, otherwise it should return ABSTAIN.",
    "snippet": "@labeling_function()\ndef country_code(x):\n    if x.country_code == 'NO':\n        return NO\n    elif x.country_code == 'SLO':\n     return SLO\n    else:\n        return ABSTAIN"
  },
  {
    "intent": "Write me a function called country_code that takes a variable x and if x's country code is equal to 'US'. then return US, if it's equal to UK return UK, otherwise return ABSTAIN.",
    "snippet": "@labeling_function()\ndef country_code(x):\n    if x.country_code == 'US':\n        return US\n    elif x.country_code == 'UK':\n        return UK\n    else:\n        return ABSTAIN"
  },
  {
    "intent": "I need a function 'criminals' that takes x and gives back the result of 'select_against_homogenous_group' when given x and the string Criminal",
    "snippet": "@labeling_function()\ndef criminals(x):\n    return select_against_homogenous_group(x, 'Criminal')"
  },
  {
    "intent": "I want a labeling function called 'criminals' that takes an argument x and returns the output of function 'select_against_homogenous_group' when given x and the string 'Criminal'",
    "snippet": "@labeling_function()\ndef criminals(x):\n    return select_against_homogenous_group(x, 'Criminal')"
  },
  {
    "intent": "Write a function called 'criminals' that takes x as input and returns the output of function 'select_against_homogenous_group' when given x and the string 'Criminal' as arguments",
    "snippet": "@labeling_function()\ndef criminals(x):\n    return select_against_homogenous_group(x, 'Criminal')"
  },
  {
    "intent": "A function with name 'criminals' and input x. It should give back the output of function select_against_homogenous_group when given as arguments the variable x and a list with an element 'Criminal'.",
    "snippet": "@labeling_function()\ndef criminals(x):\n    return select_against_homogenous_group(x, ['Criminal'])"
  },
  {
    "intent": "Define a function daf_in_parntes, that takes x and pattern1 as arguments and returns REF if the regex pattern1 is matched by x, or ABSTAIN otherwise.",
    "snippet": "@labeling_function()\ndef daf_in_parntes(x):\n    result = re.match(pattern1, x)\n    if result:\n        return REF\n    return ABSTAIN"
  },
  {
    "intent": "Write me a labeling function 'daf_in_parntes', taking x as input and a regex patten pattern1 and returning REF if the regex pattern is matched by x or else ABSTAIN",
    "snippet": "@labeling_function()\ndef daf_in_parntes(x):\n    result = re.match(pattern1, x)\n    if result:\n        return REF\n    return ABSTAIN"
  },
  {
    "intent": "Write me a labeling function 'daf_in_parntes', taking x as input and a regex patten pattern1 and returning REF if the regex pattern is matched in x and ABSTAIN in any other case.",
    "snippet": "@labeling_function()\ndef daf_in_parntes(x):\n    result = re.match(pattern1, x)\n    if result:\n        return REF\n    return ABSTAIN"
  },
  {
    "intent": "Write me an LF called daf_in_parntes, taking an argument x and a regex pattern called pattern1 and returning REF if the regex pattern is matched in x or ABSTAIN otherwise",
    "snippet": "@labeling_function()\ndef daf_in_parntes(x):\n    result = re.match(pattern1, x)\n    if result:\n        return REF\n    return ABSTAIN"
  },
  {
    "intent": "I want a function with inputs x and divisor and return 0 if the x0 field of x has a remainder of 1 when divided with divisor and x1 field of x is larger than x3 field of x, otherwise return ABSTAIN",
    "snippet": "@labeling_function()\ndef f(x: DataPoint, divisor: int) -> int:\n    # Abstain unless x0 is divisible by divisor.\n    return 0 if x.x0 % divisor == 1 and x.x1 > x.x3 else -1"
  },
  {
    "intent": "Write me a labeling function fp10h with input x that returns FP if the tp2h and the tp3h functions return ABSTAIN when given x as input, otherwise return ABSTAIN",
    "snippet": "@labeling_function()\ndef fp10h(x):\n    return FP if tp2h(x) == ABSTAIN and tp3h(x) == ABSTAIN\\\n        else ABSTAIN"
  },
  {
    "intent": "Write me a function called fp10l taking x as input that returns FP if tp1l is equal to ABSTAIN otherwise return ABSTAIN",
    "snippet": "@labeling_function()\ndef fp10l(x):\n    return FP if tp1l == ABSTAIN \\\n        else ABSTAIN"
  },
  {
    "intent": "I want a function fp10m with x argument that returns FP if tp1h returns ABSTAIN when given x as input. In any other case return ABSTAIN",
    "snippet": "@labeling_function()\ndef fp10m(x):\n    return FP if tp1h(x) == ABSTAIN \\\n        else ABSTAIN"
  },
  {
    "intent": "I want a function called fp11m with x input. It shall return FP if Sign is is x's field tracestring and a regex search with ",
    "snippet": "@labeling_function()\ndef fp11m(x):\n    return FP if ('Sign' in x.tracestring and re.search('Sign.*Receive goods or services', x.tracestring, flags=re.I)) and ('Receive goods or services' in x.tracestring and 'Receive invoice' in x.tracestring) \\\n        else ABSTAIN"
  },
  {
    "intent": "Write me a function fp12l with argument x that returns FP if 'Create PR' is at the beginning of x's tracestring field, when ignoring case. Otherwise return ABSTAIN",
    "snippet": "@labeling_function()\ndef fp12l(x):\n    return FP if re.search('^Create PR', x.tracestring, flags=re.I) \\\n        else ABSTAIN"
  },
  {
    "intent": "Write me a function fp13h with argument x that returns FP if both tp2h and tp3h functions return ABSTAIN when given x as input. Otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef fp13h(x):\n    return FP if tp2h(x) == ABSTAIN and tp3h(x) == ABSTAIN\\\n        else ABSTAIN"
  },
  {
    "intent": "I want a labeling function fp1l with argument x that returns FP if 'Create PR, Approve PR' is in tracestring field of x and 'Approve PR,Create PO' is in tracestring field of x. Else ABSTAIN",
    "snippet": "@labeling_function()\ndef fp1l(x):\n    return FP if 'Create PR,Approve PR' in x.tracestring and 'Approve PR,Create PO' in x.tracestring \\\n            else ABSTAIN"
  },
  {
    "intent": "I want a function called fp2l with argument x that will return FP if 'Create PR' is in the beginning of tracestring field of x, ignoring case, and 'Approve PR' is found exactly one time in tracestring field of x as well, ignoring case.",
    "snippet": "@labeling_function()\ndef fp2l(x):\n    return FP if re.search('^Create PR', x.tracestring, flags=re.I) and re.search('Approve PR{1}', x.tracestring, flags=re.I)\\\n        else ABSTAIN"
  },
  {
    "intent": "write a function fp6m with argument x, that returns FP if the output of function tp1h is ABSTAIN when given x. Otherwise return ABSTAIN",
    "snippet": "@labeling_function()\ndef fp6m(x):\n    return FP if tp1h(x) == ABSTAIN \\\n        else ABSTAIN"
  },
  {
    "intent": "write a function has_entities with input x that returns RELEVANT if the length of the set of the document_annotations of x is bigger than 1 otherwise return NOT_RELEVANT",
    "snippet": "@labeling_function()\ndef has_entities(x):\n    return RELEVANT if len(set(x.document_annotations)) > 1 else NOT_RELEVANT"
  },
  {
    "intent": "Return a label of HAM if the doc length is less than 100 words and any of the words are of entity type LOC",
    "snippet": "@labeling_function()\ndef has_person(x):\n    if len(doc) < 100 and any([ent.label_ == 'LOC' for ent in doc.ents]):\n        return HAM\n    else:\n        return ABSTAIN"
  },
  {
    "intent": "Return a label of HAM if the doc length is less than 20 words and any of the words are of entity type PERSON",
    "snippet": "@labeling_function()\ndef has_person(x):\n    if len(doc) < 20 and any([ent.label_ == 'PERSON' for ent in doc.ents]):\n        return HAM\n    else:\n        return ABSTAIN"
  },
  {
    "intent": "a function has_person_nlp with input x that returns HAM if length of the doc field of x is bigger than 100 and any of the entities in the entities fields of doc field of x have a label equal to 'LOC'. Otherwise return ABSTAIN",
    "snippet": "@labeling_function()\ndef has_person_nlp(x):\n    if len(x.doc) < 100 and any([ent.label_ == 'LOC' for ent in x.doc.ents]):\n        return HAM\n    else:\n        return ABSTAIN"
  },
  {
    "intent": "a function has_person_nlp with input x that returns HAM if length of the doc field of x is less than 20 and any of the entities in the entities fields of doc field of x have a label equal to 'PERSON'. Otherwise return ABSTAIN",
    "snippet": "@labeling_function()\ndef has_person_nlp(x):\n    if len(x.doc) < 20 and any([ent.label_ == 'PERSON' for ent in x.doc.ents]):\n        return HAM\n    else:\n        return ABSTAIN"
  },
  {
    "intent": "I want a function 'has treatment' with argument x that returns RELEVANT if 'treats' or 'indicates' is is the relationships_list field of x, otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef has_treatment(x):\n    return RELEVANT if 'treats' in x.relationships_list or 'indicates' in x.relationships_list else ABSTAIN"
  },
  {
    "intent": "I need a function called has_type_bacs with input x that returns RELEVANT if the field d type bacs of x is greater than zero, otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef has_type_bacs(x):\n    return RELEVANT if x.d_typ_bacs > 0 else ABSTAIN"
  },
  {
    "intent": "I want a function has_type_bhvr with argument x that returns RELEVANT if the field d_typ_bhvr is greater than 0 otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef has_type_bhvr(x):\n    return RELEVANT if x.d_typ_bhvr > 0 else ABSTAIN"
  },
  {
    "intent": "A function called has_type_chem with argument x that returns RELEVANT if the field d_typ_chem is greater than zero else ABSTAIN",
    "snippet": "@labeling_function()\ndef has_type_chem(x):\n    return RELEVANT if x.d_typ_chem > 0 else ABSTAIN"
  },
  {
    "intent": "Write has_type_diap with argument x that returns RELEVANT if the field d_typ_diap of x is greater than zero, otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef has_type_diap(x):\n    return RELEVANT if x.d_typ_diap > 0 else ABSTAIN"
  },
  {
    "intent": "A function called has_type_diap_medd_or_bhvr with argument x that gives back RELEVANT if the field d_typ_diap of x or the field d_typ_medd of x or the field d_typ_bhvr of x is bigger than zero, otherwise return ABSTAIN",
    "snippet": "@labeling_function()\ndef has_type_diap_medd_or_bhvr(x):\n    return RELEVANT if x.d_typ_diap > 0 or x.d_typ_medd > 0 or x.d_typ_bhvr > 0 else ABSTAIN"
  },
  {
    "intent": "I want a function has_type_dora with argument x that returns RELEVANT if x's field d_typ_dora is bigger than zero, otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef has_type_dora(x):\n    return RELEVANT if x.d_typ_dora > 0 else ABSTAIN"
  },
  {
    "intent": "A function has_type_dsyn with input x that gives back RELEVANT if x's d_typ_dsyn is bigger than zero, else ABSTAIN",
    "snippet": "@labeling_function()\ndef has_type_dsyn(x):\n    return RELEVANT if x.d_typ_dsyn > 0 else ABSTAIN"
  },
  {
    "intent": "A function has_type_dsyn_sosy with input x which returns RELEVANT if d_typ_dsyn field of x is greater than zero or d_typ_sosy field of x is greater than zero, else ABSTAIN",
    "snippet": "@labeling_function()\ndef has_type_dsyn_sosy(x):\n    return RELEVANT if x.d_typ_dsyn > 0 or x.d_typ_sosy > 0 else ABSTAIN"
  },
  {
    "intent": "A function has_type_elii with x input that returns RELEVANT if d_typ_elii field of x is bigger than 0, otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef has_type_elii(x):\n    return RELEVANT if x.d_typ_elii > 0 else ABSTAIN"
  },
  {
    "intent": "A function called has votes with input x. It should first calculate total_votes as the sum of the fields document_number_votes_h, document_number_votes_s and document_number_votes_t of x, having first turned those on integers. Then it returns RELEVANT if total_votes is greater or equal than one, otherwise return NOT_RELEVANT",
    "snippet": "@labeling_function()\ndef has_votes(x):\n    total_votes = int(x.document_number_votes_h) + int(x.document_number_votes_s) + int(x.document_number_votes_t)\n    return RELEVANT if total_votes >= 1 else NOT_RELEVANT"
  },
  {
    "intent": "Define a function homeless taking x as input and returning the output of function select_against_homogenous_group when called with arguments x and a list with an element 'Homeless'",
    "snippet": "@labeling_function()\ndef homeless(x):\n    return select_against_homogenous_group(x, ['Homeless'])"
  },
  {
    "intent": "If the word is an adjective and it is equal to allelic return true else false",
    "snippet": "@labeling_function()\ndef is_allelic(word):\n   if word[1] == 'JJ' and word[0] == 'allelic':\n   return True\n   else:\n   return False"
  },
  {
    "intent": "If the word is a noun and it is equal to card then return true else return false",
    "snippet": "@labeling_function()\ndef is_card(word):\n   if word[1] == 'NN' and word[0] == 'card':\n   return True\n   else:\n   return False"
  },
  {
    "intent": "If the word is a noun and it is equal to change or if it is a noun plural and it's equal to changes then return true else return false",
    "snippet": "@labeling_function()\ndef is_change(word):\n   if word[1] == 'NN' and word[0] == 'change' or word[1] == 'NNS' and word[0] == 'changes':\n   return True\n   else:\n   return False"
  },
  {
    "intent": "define is doctor reply with input x that returns RELEVANT if the field document_is_doctor_reply of x is true or the field document_user_status of x is equal to Experienced User otherwise return NOT_RELEVANT",
    "snippet": "@labeling_function()\ndef is_doctor_reply(x):\n    return RELEVANT if x.document_is_doctor_reply or x.document_user_status == 'Experienced User' else NOT_RELEVANT"
  },
  {
    "intent": "If the word is a noun and it is either gene or allele then return true else return false",
    "snippet": "@labeling_function()\ndef is_gene(word):\n   if word[1] == 'NN' and word[0] == 'gene' or word[0] == 'allele':\n   return True\n   else:\n   return False"
  },
  {
    "intent": "If the word is a noun and it is equal to insertion or if it is a noun plural and it's equal to insertions then return true else return false",
    "snippet": "@labeling_function()\ndef is_insertion(word):\n   if word[1] == 'NN' and word[0] == 'insertion' or word[1] == 'NNS' and word[0] == 'insertions':\n   return True\n   else:\n   return False"
  },
  {
    "intent": "define a function that checks if the input x is long, by first calculating the length of the field of document_text of x and then return RELEVANT if the text length is less than 1400, otherwise return ABSTAIN",
    "snippet": "@labeling_function()\ndef is_long(x):\n    text_length = len(x.document_text)\n    return RELEVANT if text_length < 1400 else ABSTAIN"
  },
  {
    "intent": "If the word is a noun and it is equal to microdeletion or if it is a noun plural and it's equal to microdeletions then return true else return false",
    "snippet": "@labeling_function()\ndef is_microdeletion(word):\n   if word[1] == 'NN' and word[0] == 'microdeletion' or word[1] == 'NNS' and word[0] == 'microdeletions':\n   return True\n   else:\n   return False"
  },
  {
    "intent": "If the word is a noun and it is equal to missense then return true else return false",
    "snippet": "@labeling_function()\ndef is_missense(word):\n   if word[1] == 'NN' and word[0] == 'missense':\n   return True\n   else:\n   return False"
  },
  {
    "intent": "If the word is a noun and it is equal to mutation or if it is a noun plural and it's equal to mutations then return true else return false",
    "snippet": "@labeling_function()\ndef is_mutation(word):\n   if word[1] == 'NN' and word[0] == 'mutation' or word[1] == 'NNS' and word[0] == 'mutations':\n   return True\n   else:\n   return False"
  },
  {
    "intent": "If the word is a noun and it is equal to nonsense then return true else return false",
    "snippet": "@labeling_function()\ndef is_nonsense(word):\n   if word[1] == 'NN' and word[0] == 'nonsense':\n   return True\n   else:\n   return False"
  },
  {
    "intent": "If the word is a noun and it is equal to proband return true else return false",
    "snippet": "@labeling_function()\ndef is_proband(word):\n   if word[1] == 'NN' and word[0] == 'proband':\n   return True\n   else:\n   return False"
  },
  {
    "intent": "If the word is a noun plural form and it is equal to probands return true else return false ",
    "snippet": "@labeling_function()\ndef is_proband(word):\n if word[1] == 'NNS' and word[0] == 'probands':\n return True\n else:\n return False"
  },
  {
    "intent": "I need a function 'journalists' that takes x and gives back the result of 'select_against_homogenous_group' when given x and the string Criminal",
    "snippet": "@labeling_function()\ndef journalists(x):\n    return select_against_homogenous_group(x, 'Criminal')"
  },
  {
    "intent": "I want a labeling function called 'journalists' that takes an argument x and returns the output of function 'select_against_homogenous_group' when given x and the string 'Criminal'",
    "snippet": "@labeling_function()\ndef journalists(x):\n    return select_against_homogenous_group(x, 'Criminal')"
  },
  {
    "intent": "Write a function called 'journalists' that takes x as input and returns the output of function 'select_against_homogenous_group' when given x and the string 'Criminal' as arguments",
    "snippet": "@labeling_function()\ndef journalists(x):\n    return select_against_homogenous_group(x, 'Criminal')"
  },
  {
    "intent": "Look up term pair in Bio101. If it finds a subclass relation there it provides a SUBCLASS/SUPERCLASS label depending\n on term pair ordering. \n",
    "snippet": "@labeling_function()\ndef kb_bio101_ds_element(cand, kb_bio101, kb_bio101_mapping):\n    return _kb_bio101_ds_positive(cand, kb_bio101, 'element', kb_bio101_mapping['element'])"
  },
  {
    "intent": "Look up term pair in KB Bio101. If it finds a subclass relation there it provides a SUBCLASS/SUPERCLASS label depending on term pair ordering.",
    "snippet": "@labeling_function()\ndef kb_bio101_ds_has_part(cand, kb_bio101, kb_bio101_mapping):\n    return _kb_bio101_ds_positive(cand, kb_bio101, 'has-part', kb_bio101_mapping['has-part'])"
  },
  {
    "intent": "Looks up term pair KB Bio101 knowledge base manually built on the first 10 chapters of Life\n Biology. If it finds a subclass relation there it provides a SUBCLASS/SUPERCLASS label depending\n on term pair ordering. If it finds both terms in the KB, but there is subclass relation it is\n give a non-taxonomic label.\n",
    "snippet": "@labeling_function()\ndef kb_bio101_ds_negative(cand, kb_bio101, kb_terms, kb_bio101_mapping):\n    return _kb_bio101_ds_negative(cand, kb_bio101, kb_terms, kb_bio101_mapping)"
  },
  {
    "intent": "Return label if any of the words from the keywords list is in the lowercased text, otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef keyword_lookup(text, keywords, label):\n    if any(word in text.lower() for word in keywords):\n        return label\n    return ABSTAIN"
  },
  {
    "intent": "Write a labeling function that takes text, keywords and label as arguments and returns label if any of the words in the keyword list are in the lowercased text. Otherwise return ABSTAIN.",
    "snippet": "@labeling_function()\ndef keyword_lookup(text, keywords, label):\n    if any(word in text.lower() for word in keywords):\n        return label\n    return ABSTAIN"
  },
  {
    "intent": "Return label if any of the words from the keyword list is in the lowercased text, otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef keyword_lookup(x, keywords, label):\n    if any(word in x.text.lower() for word in keywords):\n        return label\n    return ABSTAIN"
  },
  {
    "intent": "A function with name 'lawyers' and input x. It should give back the output of function select_against_homogenous_group when given as arguments the variable x and a list with an element 'Criminal'.",
    "snippet": "@labeling_function()\ndef lawyers(x):\n    return select_against_homogenous_group(x, ['Criminal'])"
  },
  {
    "intent": "write a function about marriage with input x that returns ADULT if the lowercased msg field of x contains either of: marriage, husband, wife, fiancee, fiance, divorce, son, daughter, pregnant, otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef lf_about_marriage(x):\nr   return ADULT if re.search('(marriage)|(husband)|(wife)|(fiancee)|(fiance)|(divorce)|(son)|(daughter)|(pregnant)|(pregnancy)', x.msg.lower()) else ABSTAIN"
  },
  {
    "intent": "Write a function lf_acquisition with arguments row and acquisition that iterates over term in acquisition and if term is in the tag field 'sentence' of row return NEGATIVE otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef lf_acquisition(row, acquisition):\n    for term in acquisition:\n        if term in row['sentence']:\n            return NEGATIVE\n    return ABSTAIN"
  },
  {
    "intent": "Write a function called lf_carry_subject with input x that checks if the object category field of x is equal to person and if the subject_category field of x is one of the following: 'chair', 'bike', 'snowboard', 'motorcycle', 'horse'. If these are both true it returns CARRY otherwise it returns ABSTAIN",
    "snippet": "@labeling_function()\ndef lf_carry_subject(x):\n    if x.object_category == 'person':\n        if x.subject_category in ['chair', 'bike', 'snowboard', 'motorcycle', 'horse']:\n            return CARRY\n    return ABSTAIN"
  },
  {
    "intent": "A function with a name lf_competition and arguments row and competition that checks for every term in competition if that term is in the sentnece tag field of row. If that is true it returns NEGATIVE otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef lf_competition(row, competition):\n    for term in competition:\n        if term in row['sentence']:\n            return NEGATIVE\n    return ABSTAIN"
  },
  {
    "intent": "Write me a function lf_contains_adult_age with input x that returns ADULT if the lowercased msg field of x is matching the regular expression I, followed by am or 'm, followed by just or only and then an age greater than 18 years old. Otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef lf_contains_adult_age(x):\n    return ADULT if re.search('i((\u2019|\\')m| am)( just| only|( just)? a)? (1[89]|[23456789]\\d)((year(s)? old)|\\.|$| )?', x.msg.lower()) else ABSTAIN"
  },
  {
    "intent": "I want a function lf_contains_bible_name with input x that iterates over the elements of Bnames and if a lowercased element of Bnames is in the lowercased text field of x, it will return RELIGIOUS. Otherwise it will return ABSTAIN",
    "snippet": "@labeling_function()\ndef lf_contains_bible_name(x):\n  for n in Bnames:\n    if str(n).lower() in str(x.text).lower():\n      return RELIGIOUS\n  return ABSTAIN"
  },
  {
    "intent": "Write me a function lf_contains_boy_girl with input x that will return KID if either boy or girl are in the lowercased msg field of x. Otherwise ABSTAIN",
    "snippet": "@labeling_function()\ndef lf_contains_boy_girl(x):\n    return KID if re.search('(boy)|(girl)', x.msg.lower()) else ABSTAIN"
  },
  {
    "intent": "A function called lf_contains_catholicism that takes an argument x and iterates over Cathterms and if one of the lowercased terms of Cathterms is in the lowercased text field of x it returns RELIGIOUS otherwise it should ABSTAIN",
    "snippet": "@labeling_function()\ndef lf_contains_catholicism(x):\n  for n in Cathterms:\n    if n.lower() in str(x.text).lower():\n      return RELIGIOUS\n  return ABSTAIN"
  },
  {
    "intent": "Write me a function lf_contains_date_parser with x input that takes the text field of x, makes it a string and strips any trailing characters and then tries to parse the resulting string as a date. If it is successful it should return DATE, if it raises an exception it returns ABSTAIN.",
    "snippet": "@labeling_function()\ndef lf_contains_date_parser(x):\n    temp = str.strip(str(x.text))\n    try:\n        datetime.datetime.strptime(temp, '%m/%d/%Y')\n        dateutil.parser.parse(temp).strftime('%m/%d/%Y')\n        return DATE\n    except:\n        return ABSTAIN"
  },
  {
    "intent": "Write me an lf contains family memb that takes input x and returns KID if the lowercased text field of x has either brother, sister, mom, mother, dad or father otherwise it returns ABSTAIN",
    "snippet": "@labeling_function()\ndef lf_contains_family_memb(x):\n    return KID if re.search('(brother)|(sister)|(mom)|(mother)|(dad)|(father)', x.msg.lower()) else ABSTAIN"
  }
]